-- ================================================
-- Requisitos / extensiones (Supabase / Postgres)
-- ================================================
create extension if not exists pgcrypto;   -- gen_random_uuid()
create extension if not exists btree_gist; -- exclusion constraints para evitar solapamientos

-- ================================================
-- Tipos
-- ================================================
do $$
begin
  if not exists (select 1 from pg_type where typname = 'turno_estado') then
    create type turno_estado as enum ('pendiente','confirmado','cancelado','asistido','ausente');
  end if;
end$$;

-- ================================================
-- USUARIO (perfil enlazado a auth.users)
-- ================================================
create table if not exists public.usuario (
  user_id         uuid primary key
                  references auth.users(id) on update cascade on delete cascade,
  dni             varchar(20) unique,
  nombre_usuario  varchar(100) not null,
  contrasenia     varchar(255) not null,    -- si usás auth de Supabase para login, podés omitirlo
  numero_telefono varchar(30),
  email           varchar(120) unique,
  created_at      timestamptz not null default now(),
  updated_at      timestamptz not null default now()
);

-- trigger para updated_at
create or replace function set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end$$;

drop trigger if exists trg_usuario_updated on public.usuario;
create trigger trg_usuario_updated
before update on public.usuario
for each row execute function set_updated_at();

-- ================================================
-- SUCURSAL (opcional, útil si hay múltiples sedes)
-- ================================================
create table if not exists public.sucursal (
  id_sucursal     bigserial primary key,
  nombre          varchar(120) not null,
  direccion       varchar(200),
  telefono        varchar(30),
  created_at      timestamptz not null default now(),
  updated_at      timestamptz not null default now()
);

drop trigger if exists trg_sucursal_updated on public.sucursal;
create trigger trg_sucursal_updated
before update on public.sucursal
for each row execute function set_updated_at();

-- ================================================
-- PRESTADOR
-- ================================================
create table if not exists public.prestador (
  id_prestador    bigserial primary key,
  usuario_dni     varchar(20),                  -- si el prestador además es usuario del sistema (opcional)
  nombre          varchar(120),
  especialidades  varchar(200),
  email           varchar(120),
  numero_telefono varchar(30),
  id_sucursal     bigint references public.sucursal(id_sucursal)
                    on update cascade on delete set null,
  created_at      timestamptz not null default now(),
  updated_at      timestamptz not null default now(),

  constraint fk_prestador_usuario_dni
    foreign key (usuario_dni) references public.usuario(dni)
    on update cascade on delete set null
);

drop trigger if exists trg_prestador_updated on public.prestador;
create trigger trg_prestador_updated
before update on public.prestador
for each row execute function set_updated_at();

-- ================================================
-- USUARIO_PRESTADOR (representante ↔ prestador)
-- ================================================
create table if not exists public.usuario_prestador (
  id_representante  bigserial primary key,
  usuario_id        uuid not null
                    references public.usuario(user_id)
                    on update cascade on delete cascade,
  id_prestador      bigint not null
                    references public.prestador(id_prestador)
                    on update cascade on delete cascade,
  nombre_negocio    varchar(150),
  created_at        timestamptz not null default now(),

  constraint unq_usuario_prestador unique (usuario_id, id_prestador)
);

-- ================================================
-- SERVICIO
-- ================================================
create table if not exists public.servicio (
  id_servicio       bigserial primary key,
  nombre            varchar(120) not null,
  descripcion       varchar(500),
  duracion_minutos  integer not null check (duracion_minutos > 0),
  precio            numeric(12,2) not null check (precio >= 0),
  created_at        timestamptz not null default now(),
  updated_at        timestamptz not null default now()
);

drop trigger if exists trg_servicio_updated on public.servicio;
create trigger trg_servicio_updated
before update on public.servicio
for each row execute function set_updated_at();

-- ================================================
-- SERVICIO_PRESTADOR (opcional: overrides por prestador)
-- ================================================
create table if not exists public.servicio_prestador (
  id                bigserial primary key,
  id_servicio       bigint not null references public.servicio(id_servicio)
                      on update cascade on delete cascade,
  id_prestador      bigint not null references public.prestador(id_prestador)
                      on update cascade on delete cascade,
  precio_override   numeric(12,2) check (precio_override >= 0),
  duracion_override integer check (duracion_override > 0),
  activo            boolean not null default true,

  constraint unq_servicio_prestador unique (id_servicio, id_prestador)
);

-- ================================================
-- PRESTADOR_DISPONIBILIDAD (franjas por día de semana)
-- ================================================
create table if not exists public.prestador_disponibilidad (
  id_disponibilidad bigserial primary key,
  id_prestador      bigint not null references public.prestador(id_prestador)
                      on update cascade on delete cascade,
  dia_semana        smallint not null check (dia_semana between 0 and 6), -- 0=Domingo … 6=Sábado
  hora_inicio       time not null,
  hora_fin          time not null,
  activo            boolean not null default true,

  constraint chk_horas_validas check (hora_fin > hora_inicio)
);

create index if not exists idx_disp_prestador_dia
  on public.prestador_disponibilidad (id_prestador, dia_semana);

-- ================================================
-- TURNO
-- ================================================
create table if not exists public.turno (
  id_turno       bigserial primary key,
  usuario_id     uuid    not null
                 references public.usuario(user_id)
                 on update cascade on delete restrict,
  id_servicio    bigint  not null
                 references public.servicio(id_servicio)
                 on update cascade on delete restrict,
  id_prestador   bigint  not null
                 references public.prestador(id_prestador)
                 on update cascade on delete restrict,
  id_sucursal    bigint
                 references public.sucursal(id_sucursal)
                 on update cascade on delete set null,
  inicio         timestamptz not null,
  fin            timestamptz not null,
  estado         turno_estado not null default 'pendiente',
  notas          text,
  created_at     timestamptz not null default now(),
  updated_at     timestamptz not null default now(),

  constraint chk_intervalo_valido check (fin > inicio)
);

drop trigger if exists trg_turno_updated on public.turno;
create trigger trg_turno_updated
before update on public.turno
for each row execute function set_updated_at();

-- Índices comunes de consulta
create index if not exists idx_turno_inicio       on public.turno (inicio);
create index if not exists idx_turno_prestador_ti on public.turno (id_prestador, inicio);
create index if not exists idx_turno_usuario_ti   on public.turno (usuario_id, inicio);

-- Evitar solapamientos de turnos por prestador (misma franja)
-- Requiere btree_gist; usa un rango para comparar superposiciones.
alter table public.turno
  add column if not exists rango tstzrange
  generated always as (tstzrange(inicio, fin, '[)')) stored;

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'excl_no_solapamiento_prestador'
  ) then
    alter table public.turno
      add constraint excl_no_solapamiento_prestador
      exclude using gist (
        id_prestador with =,
        rango with &&
      );
  end if;
end$$;

-- ================================================
-- RLS (opcional, ejemplo mínimo)
-- ================================================
-- Habilitar RLS
alter table public.usuario enable row level security;
alter table public.turno  enable row level security;

-- Política: cada usuario solo ve su propio perfil
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='usuario' and policyname='usuario_self_access'
  ) then
    create policy usuario_self_access on public.usuario
      for select using (user_id = auth.uid());
  end if;
end$$;

-- Políticas para turnos: un usuario ve y maneja SUS turnos
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='turno' and policyname='turno_select_own'
  ) then
    create policy turno_select_own on public.turno
      for select using (usuario_id = auth.uid());
  end if;

  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='turno' and policyname='turno_insert_own'
  ) then
    create policy turno_insert_own on public.turno
      for insert with check (usuario_id = auth.uid());
  end if;

  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='turno' and policyname='turno_update_own'
  ) then
    create policy turno_update_own on public.turno
      for update using (usuario_id = auth.uid())
      with check (usuario_id = auth.uid());
  end if;
end$$;

-- Nota: si querés que “admins” o “representantes” vean más, creá roles y políticas adicionales
-- que chequeen pertenencia en usuario_prestador o una tabla de roles.

-- ================================================
-- VISTAS ÚTILES (opcionales)
-- ================================================
create or replace view public.v_turnos_detalle as
select
  t.id_turno,
  t.inicio,
  t.fin,
  t.estado,
  u.nombre_usuario     as cliente,
  u.email              as cliente_email,
  p.nombre             as prestador,
  s.nombre             as servicio,
  coalesce(sp.precio_override, s.precio)            as precio_aplicado,
  coalesce(sp.duracion_override, s.duracion_minutos) as duracion_aplicada,
  su.nombre            as sucursal
from public.turno t
join public.usuario  u  on u.user_id = t.usuario_id
join public.prestador p on p.id_prestador = t.id_prestador
join public.servicio  s on s.id_servicio  = t.id_servicio
left join public.servicio_prestador sp on sp.id_servicio = s.id_servicio and sp.id_prestador = p.id_prestador
left join public.sucursal su on su.id_sucursal = t.id_sucursal;

-- Listo ✅
